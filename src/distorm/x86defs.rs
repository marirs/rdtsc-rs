pub const SEG_REGS_MAX: u32 = 6;
pub const CREGS_MAX: u32 = 9;
pub const DREGS_MAX: u32 = 8;
pub const INST_MAXIMUM_SIZE: u32 = 15; // Maximum instruction size, including prefixes.
pub const INST_CMP_MAX_RANGE: u32 = 8; // Maximum range of imm8 (comparison type) of special SSE CMP instructions.
pub const INST_VCMP_MAX_RANGE: u32 = 32; // Maximum range of imm8 (comparison type) of special AVX VCMP instructions.
pub const INST_WAIT_INDEX: u32 = 0x9b; // Wait instruction byte code.
pub const INST_LEA_INDEX: u32 = 0x8d; // Lea instruction byte code.
pub const INST_NOP_INDEX: u32 = 0x90; // NOP/XCHG instruction byte code.
pub const INST_ARPL_INDEX: u32 = 0x63; // ARPL/MOVSXD instruction byte code.
pub const INST_DIVIDED_MODRM: u32 = 0xc0; // Minimal MODR/M value of divided instructions. It's 0xc0, two MSBs set, which indicates a general purpose register is used too.
pub const _3DNOW_ESCAPE_BYTE: u32 = 0x0f; // This is the escape byte value used for 3DNow! instructions.
pub const PREFIX_LOCK: u32 = 0xf0;
pub const PREFIX_REPNZ: u32 = 0xf2;
pub const PREFIX_REP: u32 = 0xf3;
pub const PREFIX_CS: u32 = 0x2e;
pub const PREFIX_SS: u32 = 0x36;
pub const PREFIX_DS: u32 = 0x3e;
pub const PREFIX_ES: u32 = 0x26;
pub const PREFIX_FS: u32 = 0x64;
pub const PREFIX_GS: u32 = 0x65;
pub const PREFIX_OP_SIZE: u32 = 0x66;
pub const PREFIX_ADDR_SIZE: u32 = 0x67;
pub const PREFIX_VEX2B: u32 = 0xc5;
pub const PREFIX_VEX3B: u32 = 0xc4;
pub const PREFIX_REX_LOW: u32 = 0x40; // REX prefix value range, 64 bits mode decoding only.
pub const PREFIX_REX_HI: u32 = 0x4f;
pub const EX_GPR_BASE: u32 = 8; // In order to use the extended GPR's we have to add 8 to the Modr/M info values.
pub const PREFIX_EX_B: u32 = 1; // Base
pub const PREFIX_EX_X: u32 = 2; // Index
pub const PREFIX_EX_R: u32 = 4; // Register
pub const PREFIX_EX_W: u32 = 8; // Operand Width
pub const PREFIX_EX_L: u32 = 0x10; // Vector Length